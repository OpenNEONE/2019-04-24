# 一些细节

## 关于求最大值或最小值

上课时我们写了案例：找最大值和最小值问题，用的是“假设法”，上课时有同学问我借用冒泡的原理（两两比较可以不可以），这个确实是可以的，分析和代码如下：

```javascript
// 我们知道冒泡的原理是：经过一轮比较后那个最大（或者最小）的值就跑到了最后
// 所以我们只需要比较一轮
// 这一轮比较 arr.length - 1 次就可以把那个最大（或者最小）的值排到最后

// 最后一定要注意，这里我们是从前往后依次调换的，也就是最后的那个值才是我们筛选的结果（最大的或者最小的）

// 冒泡也可以从后往前进行调换，如果是这样的话，那就是第一个值才是我们想要的结果（最大的或者最小的）
var arr = [1, 43, 5, 3, 32, 43, 6, 754, 75, 86, 2, 4, 546];

for (var i = 0; i < arr.length - 1; i++) {
    if (arr[i] < arr[i + 1]) {
        var temp;
        temp = arr[i];
        arr[i] = arr[i + 1];
        arr[i + 1] = temp;
    }
}

console.log(arr[arr.length - 1]);
```

## 关于反转数组

```javascript
// 这种方法就是我们上课讲的方法，也是最容易理解的
for(var i = arr.length - 1; i >= 0 ; i --) {
    // newArr.length 是从小到大的
    // i 是从大到小的
    // 这样一来就刚好能实现反转
    newArr[newArr.length] = arr[i];
}
console.log(newArr);
```

```javascript
// 上课的时候我又提了下第二种方法
for(var i = 0; i < arr.length; i ++) {
    // 这里可以利用 i 依次增大的特性
    // 让后用 arr.length - i ，这样一来也就是 arr.length - i 的整体结果也就是依次减小的
    // 利用这种技巧也能实现反转
    newArr[newArr.length] = arr[arr.length - 1 - i];
}
console.log(newArr);
```

```javascript
// 这时候课下有同学在第二种方法的基础上为了我这样一个问题
// 能不能把  arr[arr.length - 1 - i] 这里的 i 换成是 newArr.length，因为 i 是从0依次增加的，newArr.length 也是从0依次增加的
// 想法很好，这种情况下确实是可以的，没有一点问题
var arr = [1, 2, 3, 4, 5, 6, 7];
var newArr = [];
for(var i = 0; i < arr.length; i ++) {
    newArr[newArr.length] = arr[arr.length - 1 - newArr.length];
}
console.log(newArr);
```

```javascript
// 这里我只是把上面的代码包装在一个函数里面了，其他没有做任何改动，结果必然是和上面一样的
// 但是当我对这个函数进行第二次调用的时候，大家想一想这里 arr[arr.length - 1 - newArr.length] 当中的 newArr.length 还是从0开始的吗，答案肯定不是的，因为第一次调用的时候  newArr 中已经装好了一个反转后的数组了，所以也就会出问题了
var arr = [1, 2, 3, 4, 5, 6, 7];
var newArr = [];

function test() {
    for(var i = 0; i < arr.length; i ++) {
        newArr[newArr.length] = arr[arr.length - 1 - newArr.length];
    }
    console.log(newArr);
}

test(); // 第一次调用没问题
test(); // 第二次调用出事啦
```

